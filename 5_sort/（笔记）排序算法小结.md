# （笔记）排序算法小结

> [CyC 算法 - 排序](https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F)

- **简单排序**

  - <u>冒泡排序</u>

    - 从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧

    - 在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出

    - 最好O(N)，最坏O(N^2)

  - <u>插入排序</u>

    - 每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序

    - 最好O(N)，最坏O(N^2)

- **每次交换较远的2个元素**

  - <u>希尔排序</u>

    - 使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的

    - 与增量序列有关，最坏Θ(N^2)

- **很笨的方法**

  - <u>选择排序</u>

    - 从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

    - 都是Θ(N^2)

- **快速找到最小元**

  - <u>堆排序</u>

    https://www.cnblogs.com/chengxiao/p/6129630.html 讲得很清楚

    - 把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序

    - 最佳平均时间复杂度：稍小于O(NlogN)

    - 但实际效果不如Sedgewick增量序列的希尔排序

- **分而治之**

  - <u>归并排序</u>

    - 将数组分成两部分，分别进行排序，然后归并起来

    - 需要额外的一个数组。不用于内排序，用于外排序

    - O(NlogN)。但最坏是O(N^2)

  - <u>快速排序</u>

    - 通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了

    - 快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈

    - O(NlogN)

- **排序算法的对比**

  ![image-20201030200804776](https://raw.githubusercontent.com/bobo6668/markdown-pictures-bobo/master/img/data-structure/20201030200804.png)

  - <u>快速排序</u>是最快的通用排序算法

    - 它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。

    - 它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。
    - [为什么在平均情况下快速排序比堆排序要优秀？ - 知乎](https://www.zhihu.com/question/23873747)